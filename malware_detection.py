import os
import hashlib
import math


def calculate_entropy(file_path):
    """Calculate the entropy of a file."""
    with open(file_path, 'rb') as f:
        byte_arr = list(f.read())
        file_size = len(byte_arr)
        if file_size == 0:
            return 0
        freq_list = [0] * 256
        for b in byte_arr:
            freq_list[b] += 1
        freq_list = [float(x) / file_size for x in freq_list]
        entropy = -sum([p * math.log(p, 2) for p in freq_list if p > 0])
        return entropy


def get_hashes(file_path):
    """Generate MD5 and SHA256 hashes of a file."""
    with open(file_path, "rb") as f:
        file_bytes = f.read()
        file_md5 = hashlib.md5(file_bytes).hexdigest()
        file_sha256 = hashlib.sha256(file_bytes).hexdigest()
    return file_md5, file_sha256


def extract_file_features(file_path):
    """Extract the 6 selected features from a file."""
    try:
        # Feature 1: File size (usage_counter)
        file_size = os.path.getsize(file_path)

        # Feature 2: File entropy (fs_excl_counter)
        file_entropy = calculate_entropy(file_path)

        # Feature 3: File is an executable (task_size)
        file_extension = os.path.splitext(file_path)[1]
        is_exe = 1 if file_extension == '.exe' else 0

        # Feature 4: Time since last accessed (end_data)
        last_accessed = os.path.getatime(file_path)

        # Feature 5: Time since last modified (policy)
        last_modified = os.path.getmtime(file_path)

        # Feature 6: Time since file creation (nivcsw)
        created = os.path.getctime(file_path)

        # Combine the 6 features into a dictionary
        features = {
            'usage_counter': file_size,  # usage_counter
            'fs_excl_counter': file_entropy,  # fs_excl_counter
            'task_size': is_exe,  # task_size
            'end_data': last_accessed,  # end_data
            'policy': last_modified,  # policy
            'nivcsw': created  # nivcsw
        }

        return features

    except Exception as e:
        print(f"Error extracting features from {file_path}: {e}")
        return None



import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
import joblib

# Load the dataset (replace with the path to your CSV file)
dataset = pd.read_csv('malwareDataset.csv')

# Keep only the top 6 features
selected_features = [
    'usage_counter', 'fs_excl_counter', 'task_size',
    'end_data', 'policy', 'nivcsw'
]

# Filter the dataset to keep only the selected features and the label
X = dataset[selected_features]
y = dataset['classification']  # Assuming 'classification' is the target label column

# Split dataset into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Scale the selected features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Train the Random Forest model
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train_scaled, y_train)

# Save the updated model and scaler
joblib.dump(model, 'malware_detection_model_selected_features.pkl')
joblib.dump(scaler, 'scaler_selected_features.pkl')

print("Model trained and saved with selected 6 features.")




#scaninng files

import joblib
import os

# Load the trained model and scaler
model = joblib.load('malware_detection_model_selected_features.pkl')
scaler = joblib.load('scaler_selected_features.pkl')

def scan_directory(directory_path):
    """Scan all files in a directory for malware."""
    for root, dirs, files in os.walk(directory_path):
        for file in files:
            file_path = os.path.join(root, file)
            features = extract_file_features(file_path)
            if features is not None:
                # Extract feature values from the dictionary
                feature_values = list(features.values())

                # Reshape and scale the feature values
                features_scaled = scaler.transform([feature_values])

                # Predict if the file is malware
                prediction = model.predict(features_scaled)
                if prediction == 1:
                    print(f"Malware detected: {file_path}")
                else:
                    print(f"Clean file: {file_path}")
            else:
                print(f"Error scanning {file_path}")

# Run the scan
directory_path = input("Enter the directory path to scan for malware: ")
scan_directory(directory_path)